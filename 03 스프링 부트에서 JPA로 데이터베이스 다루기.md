03 스프링 부트에서 JPA로 데이터베이스 다루기
=======================
웹 서비스를 개발하고 운영하다 보면 피할 수 없는 문제가 데이터베이스를 다루는 일이다.      
이전 데이터베이스 기술은 객체 모델링이 아닌 **테이블 모델링**에 집중되어있는 형태였고       
**객체를 테이블에 맞추어 데이터를 전달하는 형식**으로 객체지향 프로그래밍과 거리가 먼 형태였다     
그래서 이러한 문제의 해결책으로 JPA라는 자바 표준 ORM 기술을 사용해보자    

# 1. JPA 소개 
현대의 웹 애플리케이션에서 관계형 데이터베이스는 빠질 수 없는 요소이다.            
그러다 보니 객체를 관계형 데이터베이스에서 관리하는 것이 무엇보다 중요해졌다.         
이런 현상이 짙어지다 보니 모든 코드는 SQL 중심이 되기 시작했고          
현업 프로젝트는 애플리케이션 코드보다 SQL로 가득하게 되었다.       
     
개발자가 아무리 자바 클래스를 아름답게 설계해도 SQL을 통해야 데이터베이스를 사용할 수 있기에 피할 수 없다.         
하지만 **SQL 을 반복적으로 지속적으로 사용해야 하고 테이블이 수백개면 수백개의 SQL 코드를 작성해야한다.**      
그리고 **각각의 관계형 데이터베이스마다 쿼리문이 다르니 이는 기하 급수적으로 늘어나게 된다.**       

또 한가지 문제점이 있다. 바로 **패러다임 불일치**이다.    
* 관계형 데이터베이스 : **어떻게 데이터를 저장할지**
* 객체지향 프로그래밍 : **메시지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술**

예를 들면 
```
User user = findUser();
Group group = user.getGroup();
```
위 코드와 같이 User와 Group 부모 자식 관계로 User를 통해서 Group을 얻을 수 있지만
여기에 데이터베이스 코드가 들어가게 된다면  
```
User user = userDao.findUser();
Group group = GroupDao.findGroup(user.getGroupId());
```
상속, 1:N 등 다양한 객체 모델링을 데이터베이스로는 구현을 할 수 없어             
각각에 DAO를 생성해주어 따로따로 조회를 해야하는 번거로움이 생긴다.          
이렇다 보니 웹 애플리케이션 개발은 점점 데이터베이스 모델링에만 집중하게 되었다.   
     
**JPA**는 서로 지향하는 바가 다른 2개의 영역을 **중간에서 패러다임 일치**를 시켜주기 위한 기술이다.      
개발자는 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행한다.    
개발자는 객체지향 프로그래밍만 신경쓰면 되는 것으로 **SQL에 종속적인 개발을 하지 않아도 된다.**   

## 1.1. SpringData JPA 
JPA는 인터페이스로 자바 표준 명세서이다.  
즉, 인터페이스인 JPA를 사용하기 위해서는 구현체(실체)인 Hibernate, Eclipse Link등이 있다.  
  
Spring에서는 이러한 구현체를 직접 다루지 않고 이 위에 SpringData JPA 모듈을 이용하여 JPA 기술을 다룬다.   
```
JPA <- Hibernate <- SpringData JPA
```  
그럼 이렇게 사용하는 이유는 무엇이 있을까? 매번 그렇듯 유지보수를 편하기 하기 위해서이다.   
    
* 구현체 교체의 용이성  
* 저장소 교체의 용이성   

**구현체 교체의 용이성**
```
Hibernate외에 다른 구현체로 쉽게 교체하기 위함
```  
SpringData JPA 내부에서 구현체 매핑을 지원해주기 때문에    
Hibernate가 언젠가 수명을 다해서 새로운 JPA 구현체가 대세로 떠오를 경우 손쉽게 교체하기 위해서이다.     
    
**저장소 교체의 용이성**
```
관계형 데이터베이스 외에 다른 저장소로 쉽게 교체하기 위한 것이다.      
```
서비스 초기에는 관계형 데이터베이스로 모든 기능을 처리했지만,  
점점 트래픽이 많아져 관계형 데이터베이스로는 도저히 감당이 안될 때 non-sql로 교체를 할 수도 있다.(Mongo DB   
이때 개발자는 교체를 원한다면 SpringData JPA 에서 SpringData MongoDB로 의존성만 교체하면 된다.  
   
이는 SpringData의 하위 프로젝트들은 기본적으로 CRUD의 인터페이스가 같기 때문이다.  
그렇다보니 저장소가 교체되어도 기본적인 기능은 변경할 것이 없다.  
   
## 1.2. 실무에서 JPA 
실무에서 JPA를 사용하지 못하는 가장 큰 이유로 **높은 러닝 커브**를 이야기한다.   
JPA를 잘 쓰려면 객체지향 프로그래밍과 관계형 데이터베이스를 둘 다 이해해야 한다.  
   
하지만 JPA를 사용하게 되면 CRUD를 작성할 필요가 없어지고
부모-자식 관계, 1:N 관계 표현, 상태와 행위를 한 곳에서 관리하는 등 객체지향 프로그래밍을 쉽게 할 수 있다.
또한 속도 이슈도 없기에 많은 트래픽을 처리하는데도 사용해도 된다.  

## 1.3. JPA 사용하기
     
**게시판 기능**   
   
* 게시글 조회
* 게시글 등록
* 게시글 수정
* 게시글 삭제
___   
**회원 기능**   
    
* 구글 / 네이버 로그인    
* 로그인한 사용자 글 작성 권한    
* 본인 작성 글에 대한 권한 관리    
___

### 1.3.1. 프로젝트에 Spring Data Jpa 적용하기

1. 라이브러리 의존성 주입 받기   
**build.gradle**   
```

```
   
```
spring-boot-starter-data-jpa
  * 스프링 부트용 Spring Data Jap 추상화 라이브러리입니다.  
  * 스프링 부트 버전에 맞춰 자동으로 JPA 관련 라이브러리들의 버전을 관리해줍니다.  
________________________________________________________________________________
h2
  * 인메모리 관계형 데이터베이스입니다.      
  * 별도의 설치가 필요 없이 프로젝트 의존성만으로 관리할 수 있습니다.      
  * 메모리에서 실행되기 때문에 애플리케이션을 재시작할 때마다 초기화된다는 점을 이용하여 테스트 용도로 많이 사용된다.       
  * 이 책에서는 JPA의 테스트, 로컬 환경에서의 구동에서 사용할 예정이다.     
  * 필자 주관으로 oracle의 sqlite 같은 격  
``` 

2. 폴더(패키지) 생성
  1. java 폴더 -> 디폴트 패키지에 domain 폴더 생성 
   
domain은 게시글, 댓글, 회원, 정산, 결제 등 소프트웨어에 대한 요구사항 혹은 문제 영역이라 생각하자  
기존 객체,DAO,xml 구조와 달리 객체클래스에서만 해결할 수 있다는 차이점에서 나온 용어이다.   

3. Posts, User 소스 코드 작성
    
**Posts**    
```java

```
Posts 클래스는 실제 DB의 테이블과 매칭될 클래스이며 보통 Entity 클래스라고 부른다.     
JPA를 사용한다면 DB 데이터에 작업할 경우 실제 쿼리를 날리기보다는, 이 Entity 클래스의 수정을 통해 작업한다.       
     
**꿀팁**   
```
웬만하면 Entity의 PK는 Long 타입의 Auto_increment를 추천한다.  
주민등록번호와 같이 비즈니스상 유니크 키나, 여러 키를 조합한 복합키로 PK를 선정할 경우 
   
1. FK 를 맺을때 다른 테이블에서 복합키 전부를 갖고 있거나, 중간 테이블을 하나 더 두는 상황이 생긴다.  
2. 인덱스에 좋은 영향을 끼치지 못한다.  
3. 유니크한 조건이 변경될 경우 PK 전체를 수정해야 하는 일이 발생한다.  
그렇기에 주민등록 번호, 복합키 등은 유니크 키로 별도로 추가를 해주자
```

**코드 해석**
```
@Entity
  * 테이블과 링크될 클래스임을 나타낸다.  
  * 기본값으로 클래스의 카멜케이스 이름을 언더스코어 네이밍으로 테이블 이름을 매칭한다.  
  * SalesManager.java -> sales_manager table
____________________________________________________________________________________
@Id
  * 해당 테이블의 PK 필드를 나타낸다.
____________________________________________________________________________________
@GerneratedValue
  * PK의 생성 규칙을 나타낸다.  
  * 스프링부트 2.0 에서는 GenerationType.IDENTITY 옵션을 추가해야만 auto_increment가 된다.   
  * 참고 사이트 : https://jojoldu.tistory.com/295에 정리
____________________________________________________________________________________
@Column
  * 테이블의 칼럼을 나타내며 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 칼럼이 된다.  
  * 사용하는 이유는, 기본값 외에 추가로 변경이 필요한 옵션이 있으면 사용한다.  
  * 문자열의 경우 VARCHAR(255)가 기본값인데, 사이즈를 500으로 늘리고 싶거나, 
  타입을 TEXT로 변경하고 싶거나 등의 경우에 사용된다.  
____________________________________________________________________________________
@NoArgsConstructor
  * 기본 생성자 자동 추가 -> public Posts(){}
____________________________________________________________________________________
@Getter
  * 클래스 내 모든 필드의 Getter 메소드를 자동생성  
____________________________________________________________________________________
@Builder
  * 해당 클래의 빌더 패턴 클래스를 생성
  * 생성자 상단에 선언시 생성자에 포함된 빌드만 빌더에 포함  
  * 매개변수의 순서가 달라도 이름에 맞춰 알아서 값을 넣어준다고 보면 된다.    
```
이 Posts 클래스에는 한 가지 특징이 있는데 바로 Setter 메소드가 없다.     
자바빈 규약을 따지면 Getter/Setter 메소드를 정의해주는 것이 좋긴 하지만   
이렇게 되면 해당 클래스의 인스턴스 값들이      
언제 어디서 변해야 하는지 코드상으로 명확하게 구분할 수가 없어, 차후 기능 변경시 정말 복잡해진다.    
그래서 **Entity 클래스에서는 절대 Setter 메소드를 만들지 않는다.**      
대신 필드의 값 변경이 필요하면 명확히 그 목적과 의도를 나타낼 수 있는 메소드를 추가해야만 한다.     
```java
public class Order{
     public void setStatus(boolean status){
          this.status = status;
     }
     public void 주문서비스의_취소이벤트(){
          order.setStatus(false);
     }
}
```
위와 같이 Setter는 단순히 값을 세팅하는 것이기에 명확하게 목적과 의도를 나타내주지 못한다.  
```java
public class Order{
     public void cancleOrder(){
          this.status = false;
     }
     public void 주문서비스의_취소이벤트(){
          order.cancleOrder();
     }
}
```
위와 같이 메소드에 이름을 정확히 나타내주면 어떠한 목적과 의도로 값을 세팅하는지 파악이 가능해진다.  










## 1.1. 소 주제
### 1.1.1. 내용1
```
내용1
```
## 1.2. 소 주제
### 1.2.1. 내용1
```
내용1
```

***
# 2. 대주제
> 인용
## 2.1. 소 주제
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
