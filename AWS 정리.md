# EC2
EC2 는 AWS에서 제공하는 성능, 용량등을 유동적으로 사용할 수 있는 서버입니다.   

0. AWS 서비스에서 EC2 검색 
1. EC2 인스턴스 시작 
2. 알맞은 OS 선정 -> 아마존 리눅스1 AMI 선정 (2는 유료)
3. 인스턴스 유형에는 프리티어로 표기된 것 사용 (무료로 사용가능하다는 말)   
4. 세부정보는 설정하지 않고 넘어가기
5. 스토리지는 30GB 까지 프리티어로 사용가능하므로 업시킨다.     
6. 여러 인스턴스가 있을 경우 태그별로 구분하면 검색이나 그룹짓기 편하므로 태그를 추가해준다.  
7. 보안그룹은 특정 포트만 허용하는 것이므로 22(ssh),8080(http),443(https)을 설정해준다.     
8. 검토하고 문제없으면 다음으로 
9. pem 키를 생성한다. -> EC2 접근을 하기 위한 키 -> 이름을 입력하고 키 페어 다운로드를 클릭  
  * 인스턴스는 지정된 pem키와 매칭되는 공개키를 가지고 있어 해당 pem 키외에는 허용하지 않는다.   
  * 또한 일종의 마스터키이기 때문에 유출하면 안된다.  
  * 잘 관리할 수 있는 디렉토리로 저장하자  
10. ec2 목록으로 이동
11. 생성된 인스턴스를 클릭해보면 IP와 도메인을 확인할 수 있다.    
12. 인스턴스도 하나의 서버이기에 IP가 존재하는데 아마존에서는 인스턴스를 중지하고 다시 켤때 새 IP를 할당한다.   
13. 매번 확인하고 고쳐주는 귀찮은 작업을 해결하기 위해 탄력적 IP를 도입해준다.  
  * EC2 인스턴스 페이즈의 왼쪽 카테고리에서 탄력적IP를 눌러 선택하고 주소가 없으므로 [새 주소 할당] 클릭  
  * 아마존 풀 클릭 하고 할당하면 생성됨
14. 기존 EC2와 탄력적 IP연결 
  * 방금 생성한 탄력적 IP를 확인하고 페이지 위에 있는 [작업]->[주소 연결] 클릭
  * 연결을 위해 EC2 이름과 IP를 선택하고 연결 클릭
  * 연결이 완료되면 왼쪽 카테고리의 인스턴스 목록의 인스턴스 클릭
  * 해당 인스턴스의 퍼블릭, 탄력적 IP가 모두 잘 연결되었는지 확인
  * 탄력적 IP는 주소연결을 안하면 비용발생하므로 꼭 연결하기  
15. EC2서버에 접속하기
  * ```ssh -i pem '키 위치' 'EC2의 탄력적 IP주소' ``` 입력 
  * 하지만 매번 긴 명령어를 입력하는 것은 귀찮으므로 쉽게 접속해보자
  * pem 파일을 ```./ssh```로 복사한다.
  * ```./ssh``` 디렉터로리 pem 파일을 옮겨 놓으면 ssh 실행기 pem키 파일을 자동으로 읽어온다.  
  * 이후 별도로 pem 키 위치를 명령어로 지정할 필요가 없게 됩니다.  
  * 복사하기 ```cp 'pem 키를 내려받은 위치(.pem파일)' ~./ssh```
  * 이동후 확인하기 ```cd ~./ssh`` -> ```ll``` 있는지 확인
  * 복사가 되었다면 ```chmood 600 ~/.ssh/pem키 이름``` 으로 권한 변경 -> 읽고 쓰기  
  * 권한을 변경하였다면 pem 키가 있는 ```./ssh``` 디렉토리에 config 파일 생성
  * ```vim ~/.ssh/config```
  ```
  # 주석
  HostName ec2의 탄력적 IP주소 
  User ec2-user
  IdentityFile ~/.ssh/pem키 이름
  ```
  * :wq로 저장
  * ```chmod 700 ~/.ssh/config```로 권한 변경
  * ssh config에 등록한 서비스명 
  * yes 입력 
  * 접속 성공 
  
## EC2 서버에서 꼭 설정해야할 요소들 
   
* 자바8 설정 : 
* 타임존 변경 : 기본 서버의 시간은 미국 시간대이므로 한국 시간대가 되어야 우리가 사용하는 시간이 모두 한국 시간으로 등록되고 사용  
* 호스트 네임 변경 : 햔제 접속한 서버의 별명을 등록,  
실무에서는 한 대의 서버가 아닌 수십 대의 서버가 작동되는데,   
IP만으로 어떤 서버가 어떤 역할을 하는지 알 수 없습니다.   
이를 구분하기 위해 보통 호스트 네임을 필수로 등록합니다.  

### Java 8 설치   
```
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
```
자바8 설치 
```
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
```
EC2 인스턴스의 자바 버전을 8로 설정
```
sudo /usr/sbin/alternatives --config java
```
```
1.   자바7
2.   자바8
```
이런식으로 뜰 텐데 자바8이 있는 번호 선택 -> 2번 선택   
```
sudo yum remove java-1.7.0-openjdk
```
자바7 삭제   
```
java -version
```
자바 버전 확인 -> 8이면 완벽    
    
### 타임존 변경   
EC2 서버의 기본 타임존은 UTC입니다.   
이는 세계 표준 시간으로 한국의 시간대가 아닙니다. -> 9 시간 차이   
이렇게 되면 서버에서 수행되는 Java 애플리케이션에서 생성되는 시간도 모두 9시간씩 차이가 나기 때문에 수정해야한다.   
서버의 타임존을 한국 시간으로 변경하겠습니다.   
    
```
sudo rm /etc/localtime
sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime
```
정상적으로 수행되었다면 date 명령어로 타임존이 KST로 변경된 것을 확인할 수 있습니다.   
    
### Hostname 변경    
여러 서버를 관리 중일 경우 IP만으로 어떤 서비스의 서버인지 확인이 어렵습니다.     
그래서 각 서버가 어느 서비스인지 표현하기 위해 HOSTNAME을 변경하겠습니다.       
다음 명령어로 편집 파일을 열어봅니다.   
   
```
sudo vim /etc/sysconfig/network    
```
화면에서 노출되는 항목 중 HOSTNAME으로 되어 있는 부분을 **본인이 원하는 서비스명으로 변경합니다.**    
```
NETWORK=yes
HOSTNAME=localhost.localdomain <- 여기
NOZEROCONF=yes
```
```
NETWORK=yes
HOSTNAME=freelec-springboot2-webservice <- 여기  
NOZEROCONF=yes
```
변경한 후 다음 명령어로 서버를 재부팅 합니다.   
```
sudo reboot
```
재부팅이 끝나고 나서 다시 접속해 보면 HOSTNAME이 잘 변경된 것을 확인할 수 있습니다.    

___  

Hostname이 등록되었다면 한 가지 작업을 더 해야 합니다.      
호스트 주소를 찾을 때 가장 먼저 검색해보는 ```/etc/hosts```에 변경한 hostname을 등록합니다.     
만약 하지 않았을 경우 https://woowabros.github.io/experience/2017/01/20/billing-event.html 들어가보기   
    
내용요약 : 
과거 버전에서 hostname이 local 호스트이면 바로 반환하게끔 했지만 
localhost가 아닐 경우 lookupAllHostAddr() 메서드가 사용된다.   
이름 그대로 모든 host 주소를 찾는 것이기에 시간이 오래걸리고 (6초)     
시간이 오래걸리다 보니 빌링 데이터베이스의 connect_timeout 설정값이 5초였기 때문에 당연히 에러가 발생   
mariadb-connector-j 에서는 JNA를통하여 현재 pid만 반환하도록 하는 내용이 commit되었다.   

우리는 호스트 네임을 localhost 가 아닌 판별을 위한 이름을 지어주었으므로   
/etc/hosts에 IP주소와 hostname을 등록하여 최우선적으로 IP 주소를 반환하도록 합니다.    

```
sudo vim /etc/hosts
```
해당 폴더에 들어가서 
```
127.0.0.1 등록한 호스트네임
```
위와 같이 바꿔준다.  
```:wq```로 저장하고  
정상적으로 등록이 되었는지 확인하기 위해 ```curl 등록한 호스트네임```을 입력해본다.   
만약 잘못 등록되었다면 찾을 수 없는 주소라 뜨고      
잘 등록되었다면 80번 포트로 접근이 안된다는 에러가 발생합니다.     
  
이는 아직 80번 포트로 실행된 서비스가 없음을 의미합니다.(우리는 8080 사용함)   
즉, curl 호스트 이름으로 실행은 잘 되었음을 의미합니다.   
   
# RDS 
AWS에서는 모니터링, 알람, 백업, HA 구성등을 모두 지원하는 관리형 서비스인 RDS를 제공합니다.      
RDS는 AWS에서 지원하는 클라우드 기반 관계형 데이터베이스입니다.  
하드웨어 프로비저닝, 데이터베이스 설정, 패치 및 백업과 같이 잦은 운영 작업을 자동화하여    
개발자가 개발에 집중할 수 있게 지원하는 서비스입니다.      
추가로 조정 가능한 용량을 지원하여    
예상치 못한 양의 데이터가 쌓여도 비용만 추가로 내면 정상적으로 서비스가 가능한 기능도 있습니다.    

1. 서비스에 RDS라 검색
2. [데이터베이스 생성] 클릭 
3. 아마존 자체 데이터베이스인 Amazone Aurora 로 교체하기 쉽고 무료인 MariaDB 선택  
4. 무료버전인 프리티어 클릭 
5. 스토리지에서 범용(SSD), **할당된 스토리지는 20으로 바꿔줍니다**  
6. 화면을 내리면 DB 인슽턴스와 마스터 정보를 등록할 수 있다.  
 * 본인만의 DB 인스턴스 이름과 사용자 정보를 등록합니다.  
 * 여기서 입력된 정보로 실제 데이터베이스에 접근하게 되니 어딘가 내용을 메모합시다.  
7. 네트워크 퍼블릭 에세스를 [예] 로 변경합니다. -> 이후 보안 그룹에서 저장된 IP로만 접근하도록 막을 것이므로 상관x   
8. 데이터베이스 이름을 정하고 포트는 3306, db 파라미터 그룹은 옵션 그룹이랑 동일하게 맞춘다.  
9. [완료] 버튼 클릭 
10. [DB 인스턴스 세부 정보 보기]를 클릭하여 상태를 확인하고 다 생성되었다면 본격적으로 설정 시작   

## RDS 운영환경에 맞는 파라미터 설정 
1. 타임존 
2. Character Set 
3. Max Connection   
   
1. 왼쪽 카테고리에서 [파라미터 그룹] 탭을 클릭해서 이동합니다.     
2. 화면 오른쪽 위의 [파라미터 그룹 생성] 버튼을 클릭하빈다.    
3. 세부 정보 위쪽에 DB 엔진을 선택하는 항목이 있는데 **방금 생성한 MariaDB와 같은 버전으로 맞춰줘야합니다.**    
4. 생성이 완료되면 파라미터 그룹 목록창에 새로 생성된 그룹을 볼 수 있고 해당 파라미터 그룹을 클릭합니다.     
5. 이동한 페이지의 오른쪽 위쪽을 보면 [파라미터 편집] 버튼이 있으며 해당 버튼을 클릭해줍니다.     
6. time_zone 을 검색하여 [Asia/Seoul]을 선택합니다.      
7. 다음으로 Character Set을 변경합니다.           
**character 항목들은 utf8mb4 로**      
**collation 항목들은 utf8mb4_general_ci 로 변경합니다**         
utf8과 utf8mb4의 차이는 **이모지 저장 가능 여부입니다**     
utf8mb4는 이모지를 저장할 수 있으므로 해당 인코딩을 사용합니다.         
  
 * character_set_client  
 * character_set_connection 
 * character_set_database    
 * character_set_filesystem  
 * character_set_results    
 * collation_connection   
 * collation_server     
    
8. 마지막으로 Max Connection을 수정합니다.   
RDS의 MaxConnection은 인스턴스 사양에 따라 자동으로 정해집니다.    
현재 프리티어 사양으로는 약 60개의 커넥션만 가능해서 좀 더 넉넉한 값으로 지정합니다. (150)     
이후에 RDS 사양을 높이게 된다면 기본값으로 다시 돌려 놓으면 됩니다.     
설정이 다 되었다면 오른쪽 위의 [변경사항 저장] 버튼을 클릭해 최종 저장합니다.     



 
